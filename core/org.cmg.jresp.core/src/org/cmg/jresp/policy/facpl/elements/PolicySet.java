package org.cmg.jresp.policy.facpl.elements;

import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;

import org.cmg.jresp.policy.AuthorizationDecision;
import org.cmg.jresp.policy.AuthorizationRequest;
import org.cmg.jresp.policy.AuthorizationResponse;
import org.cmg.jresp.policy.facpl.FulfilledObligation;
import org.cmg.jresp.policy.facpl.ICombiningAlgorithm;
import org.cmg.jresp.policy.facpl.MatchDecision;
import org.cmg.jresp.policy.facpl.RuleEffect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class PolicySet extends FACPLPolicy {

	private LinkedList<FACPLPolicy> polElements;
	protected Class<? extends ICombiningAlgorithm> algCombining;

	protected PolicySet() {
	}

	protected void addCombiningAlg(Class<? extends ICombiningAlgorithm> alg) {

		this.algCombining = alg;
	}

	protected void addElement(FACPLPolicy el) {
		if (this.polElements == null) {
			this.polElements = new LinkedList<FACPLPolicy>();
		}
		this.polElements.add(el);
	}

	@Override
	public AuthorizationResponse evaluate(AuthorizationRequest request, String thisValue) {
		Logger l = LoggerFactory.getLogger(Rule.class);
		l.debug(idElement + ": start rule eval");

		AuthorizationResponse dr = new AuthorizationResponse();
		try {

			// Target Evaluation
			MatchDecision match_target = getTargetDecision(request, thisValue);

			switch (match_target) {
			case NO_MATCH:
				dr.setDecision(AuthorizationDecision.NOT_APPLICABLE);

				// System.out.println(dr.toString());

				return dr;

			case MATCH:
				Class<?> params[] = new Class[3];
				params[0] = List.class;
				params[1] = AuthorizationRequest.class;
				params[2] = String.class;

				Method eval = algCombining.getDeclaredMethod("evaluate", params);
				Object alg = algCombining.newInstance();

				dr = (AuthorizationResponse) eval.invoke(alg, this.polElements, request, thisValue);

				LinkedList<FulfilledObligation> listObl = null;
				if (dr.getDecision().equals(AuthorizationDecision.PERMIT)) {
					listObl = this.evaluateObl(RuleEffect.PERMIT, request);
				} else if (dr.getDecision().equals(AuthorizationDecision.DENY)) {
					listObl = this.evaluateObl(RuleEffect.DENY, request);
				}
				// addObligation to decision result (PolicySet's obligation)
				if (listObl != null) {
					dr.addObligations(listObl);
				}

				l.debug("Policy: " + idElement + " " + dr.toString() + "\n");

				return dr;

			case INDETERMINATE:
				dr.setDecision(AuthorizationDecision.INDETERMINATE);
				return dr;
			default:
				throw new Exception();
			}

		} catch (Throwable e) {
			// catch exception generated by reflection
			e.printStackTrace();
			return new AuthorizationResponse(AuthorizationDecision.INDETERMINATE, null);
		}
	}

}
